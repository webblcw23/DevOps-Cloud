trigger:
  branches: { include: [ main ] }
  paths:
    include:
      - frontend/**
      - functions/**
      - terraform/**
      - pipelines/**

variables:
  vmImage: 'ubuntu-latest'
  serviceConnection: 'sc-rangers-tracker'      # Azure RM service connection (RG-scoped)
  subscriptionId: '91c0fe80-4528-4bf2-9796-5d0f2a250518'
  resourceGroup: 'FootballScoresRG'
  stateStorage: '<REPLACE_STATE_STORAGE>'
  stateContainer: 'tfstate'
  backendKey: 'dev.terraform.tfstate'
  location: 'uksouth'
  functionAppName: 'rtk-dev-func'
  staticStorage: 'strtkfrontend'               # must match Terraform output/name

stages:
- stage: Build
  displayName: Build artifacts
  jobs:
  - job: build
    pool: { vmImage: $(vmImage) }
    steps:
    - task: UseDotNet@2
      inputs: { packageType: 'sdk', version: '8.x' }
    - script: |
        set -e
        echo "Package frontend (static files)"
        mkdir -p $(Build.ArtifactStagingDirectory)/frontend
        cp -R frontend/* $(Build.ArtifactStagingDirectory)/frontend/

        echo "Build Functions"
        dotnet restore functions
        dotnet publish functions -c Release -o $(Build.ArtifactStagingDirectory)/functions
      displayName: Build
    - publish: $(Build.ArtifactStagingDirectory)/frontend
      artifact: frontend
    - publish: $(Build.ArtifactStagingDirectory)/functions
      artifact: functions

- stage: Plan
  displayName: Terraform plan
  dependsOn: Build
  jobs:
  - job: plan
    pool: { vmImage: $(vmImage) }
    steps:
    - checkout: self
    - task: AzureCLI@2
      displayName: Terraform init/plan
      inputs:
        azureSubscription: $(serviceConnection)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e
          cd terraform/environments/dev
          cat > backend.tf <<EOF
          terraform {
            backend "azurerm" {
              resource_group_name  = "$(resourceGroup)"
              storage_account_name = "$(stateStorage)"
              container_name       = "$(stateContainer)"
              key                  = "$(backendKey)"
            }
          }
          EOF
          terraform -version
          terraform init -upgrade
          terraform validate
          terraform plan -var location=$(location) -var tenant_id=$(ARM_TENANT_ID) -out plan.out
    - publish: terraform/environments/dev
      artifact: tfplan

- stage: Apply
  displayName: Terraform apply (manual)
  dependsOn: Plan
  condition: succeeded()
  jobs:
  - job: apply
    pool: { vmImage: $(vmImage) }
    steps:
    - download: current
      artifact: tfplan
    - task: AzureCLI@2
      displayName: Terraform apply
      inputs:
        azureSubscription: $(serviceConnection)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e
          cd $(Pipeline.Workspace)/tfplan
          terraform apply -auto-approve plan.out

- stage: Deploy
  displayName: Deploy frontend + functions
  dependsOn: Apply
  jobs:
  - job: deploy
    pool: { vmImage: $(vmImage) }
    steps:
    - download: current
      artifact: frontend
    - download: current
      artifact: functions

    - task: AzureCLI@2
      displayName: Upload static site
      inputs:
        azureSubscription: $(serviceConnection)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e
          az storage blob upload-batch \
            --account-name $(staticStorage) \
            --auth-mode login \
            -d '$web' -s $(Pipeline.Workspace)/frontend --overwrite

    - task: AzureCLI@2
      displayName: Deploy Functions (zip)
      inputs:
        azureSubscription: $(serviceConnection)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e
          cd $(Pipeline.Workspace)/functions
          zip -r ../functions.zip .
          az functionapp deployment source config-zip \
            -g $(resourceGroup) -n $(functionAppName) \
            --src $(Pipeline.Workspace)/functions.zip

    - script: |
        set -e
        echo "Smoke test API"
        API="https://$(functionAppName).azurewebsites.net/api/results"
        for i in {1..10}; do
          code=$(curl -s -o /dev/null -w "%{http_code}" "$API" || true)
          echo "Attempt $i -> $code"
          [ "$code" = "200" ] && exit 0
          sleep 5
        done
        echo "API health check failed" && exit 1
      displayName: Smoke test
